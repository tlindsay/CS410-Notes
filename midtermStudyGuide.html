<!DOCTYPE html>
<html>
	<head>
		<title>Programming Languages Notes</title>
		<meta charset="UTF-8">
		<link rel="stylesheet" href="css/bootstrap.css" />
		<link rel="stylesheet" href="css/example.css" />
		<link rel="stylesheet" href="css/aside.css">
		<link rel="stylesheet" href="css/question.css">
		<link rel="stylesheet" type="text/css" charset="utf-8" href="css/style.css" />
		<script src="js/require.js"></script>
		<script src="js/jquery-1.8.2.min.js"></script>
		<script src="js/showdown.js"></script>
	</head>
	<body>
		<!-- <div class="container"> -->
			<div class="row">
				<div class="hero-unit">
					<h1 class="title">CS 410W - Programming Languages</h1>
				</div>
				<div class="col-lg-3">
					<div data-spy="affix" class="TOContents affix" id="TOC">
						<h1>Table of Contents</h1>
						<ul>
							<li>
								<a href="#test-questions">Test Questions</a>
								<ul>
									<li><a href="#chapter1">Chapter 1</a></li>
									<li><a href="#chapter2">Chapter 2</a></li>
									<li><a href="#chapter3">Chapter 3</a></li>
									<li><a href="#chapter5">Chapter 5</a></li>
									<li><a href="#chapter6">Chapter 6</a></li>
								</ul>
							</li>
							<li><a href="#glossary">Glossary</a></li>
							<li>
								<a href="#languages">Languages</a>
								<ul>

								</ul>
							</li>
						</ul>
						<a href="index.html" class="btn btn-success btn-lg btn-block">Back to Notes</a>
					</div>
					<!-- <div data-spy="affix" id="todo-list" class="todo affix">
						<div markdown="1">
							<script>
								var todoMD = $().load('Todo.mdown').text();
								// var todoMD = todoMD.text();
								var converter = new Showdown.converter();
								var todoHTML = converter.makeHtml(todoMD);
								$('#todo-list').html(todoHTML);
								// document.write()
							</script>
						</div>
					</div> -->
				</div>
				<div class="col-lg-9">
					<div class="content">
						<section id="test-questions">
							<h1>Test Questions</h1>
							<h2 id="one-pointers">One Pointers</h2>
							<h3>Costs to Use</h3>
							<ul>
								<li>
									Cost to Learn or Train
									<ul>
										<li><span class="good">Pascal</span></li>
										<li><span class="good">BASIC</span></li>
										<li><span class="bad">APL</span></li>
									</ul>
								</li>
								<li>
									Cost to Write a Program
									<ul>
										<li><span class="good">SmallTalk</span></li>
										<li><span class="good">APL</span></li>
									</ul>
								</li>
								<li>
									Cost of a Translator (Cost to Implement)
									<ul>
										<li><span class="good">Pascal</span></li>
										<li><span class="bad">ADA</span></li>
									</ul>
								</li>
								<li>
									Cost of Translation
									<ul>
										<li><span class="good">Pascal</span></li>
										<li><span class="bad">PL/I</span></li>
										<li><span class="bad">Ada</span></li>
									</ul>
								</li>
								<li>
									Cost of Execution
									<ul>
										<li><span class="good">Fortran</span></li>
										<li><span class="bad">COBOL</span></li>
									</ul>
								</li>
								<li>
									Cost of Reliability
									<ul>
										<li><span class="good">Ada</span></li>
										<li><span class="bad">C</span></li>
									</ul>
								</li>
								<li>
									Cost of Maintenance
									<ul>
										<li><span class="good">Ada</span></li>
										<li><span class="bad">APL</span></li>
									</ul>
								</li>
							</ul>
							<h3>Characteristics of a "Good" Programming Language</h3>
							<ul>
								<li>Readability <span class="good">COBOL</span> </li>
								<li>Writeability <span class="good">APL</span></li>
								<li>Reliability <span class="good">Ada</span></li>
								<li>Ease of Program Verification <span class="good">Prolog</span></li>
								<li>Program Environment <span class="good">SmalTalk</span></li>
								<li>Portability <span class="good">Java</span></li>
								<li>Well Defined Description of Semantics and Syntax <span class="good">SNOBOL</span></li>
							</ul>
							<h3>Which Languages Did What?</h3>
							<ul>
								<li>First language to be widely used: FORTRAN</li>
								<li>Slow, functional/applicative, poor memory management: LISP</li>
								<li>Machine independent, but lacked I/O or commercial support from large companies: ALGOL</li>
								<li>First high-level language to have a construct for macros: COBOL</li>
								<li>First to create concurrent tasks, psecify if a subprogram is recursive, have pointers, cross sections of arrays: PL/I</li>
								<li>Only language to go right to left and have an "overstrike" symbol: APL</li>
								<li>Language that was designed for string manipulation: SNOBOL</li>
								<li>APL is an example of a language with no precedence of operators</li>
								<li>ADA and Pascal are examples of languages which have sets built in</li>
								<li>APL is a language that has operators which act on entire structures (arrays)</li>
								<li>FORTRAN is a language which stores arrays in column major form</li>
								<li>Pascal and ADA are languages where a pointer can only point to one type</li>
								<li>SmallTalk is a language where a pointer may point to any type</li>
								<li>SNOBOL, APL, and LISP are all languages which use the dynamic scoping rule</li>
								<li>FOTRAN (older versions) is a language that used static variables</li>
								<li>BASIC is a language which emphasized overall simplicity</li>
								<li>Pascal is a language which has a lack of feature multiplicity (redundancy)</li>
								<li>FOTRAN is a language which did not have operator overloading</li>
								<li>ALGOL68 is a language which supported orthogonality</li>
								<li>FORTRAN is a language where whitespace was totally ignored</li>
								<li>SNOBOL is a language which used whitespace as an operator</li>
								<li>COBOL is a language which used noise words</li>
								<li>Pascal is a language which had unlimited length identifiers, but only a fixed length was used for differentiation</li>
								<li>APL is a language which had expressivity</li>
								<li>LISP is a language which works well for artificial intelligence</li>
								<li>LISP was the first functional language</li>
								<li></li>
							</ul>
							<h3>What did Algol contribute to the programming landscape? (does not necessarily mean it did it first (i.e. LISP was first to offer recursion, ALGOL was first imperative language to do so))</h3>
							<ol>
								<li>Formalized the concept of a data type</li>
								<li>Added the compound statement</li>
								<li>Recursion</li>
								<li>Parameter passing (by value or name)</li>
								<li>Used := as the assignment operator</li>
								<li>Unlimited length identifiers</li>
								<li>Lower bound of array subscripts may be specified</li>
								<li>Any number of array dimensions</li>
								<li>Used BNF to specify its syntax</li>
							</ol>
							<h2 id="chapter1">Chapter 1</h2>
							<ol>
								<li>
									<h3>
										Why should someone study programming 	languages?
									</h3>
									<p>
										Studying programming languages is beneficial in that it aids in learning new languages, increases our language vocabulary, improves our algorithm development, aids in the design of new languages, aids in the choice of a language to use to implement a project, increases our understanding of the languages we currently use, and encourages the survival of "good" languages and the extinction of "bad" languages.
									</p>
								</li>
								<li>
									<h3>
										What are the differences between high level and low level languages?
									</h3>
									<p>
										High level languages are generally very readable (use English like words), translated by a compiler or interpreter, very powerful, and have a one to many translation rate. On the other hand, low level languages are not very readable, must be translated by an assembler, very efficient, and have a one to one translation rate
									</p>
								</li>
								<li>
									<h3>
										What are the attributes of a "good" programming language? Discuss the details of each attribute.
									</h3>
									<p>
										The attributes of a good programming language are readability/clarity, write-ability, reliability, naturalness for the application, ease of program verification, a good programming environment, portability, a well-defined description of the syntax and semantics, generality, and low cost of use. Readability is supported by overall simplicity (small set of language construct), lack of feature multiplicity (redundancy), lack of operator overloading, orthogonality, adequate data structures and data types provided by the language, and a syntax which is readable. Syntax features which increase usability are the use of reserved words and the inclusion of noise words. Write-ability or the ease of creating a program is supported by simplicity, orthogonality, support of abstraction, and expressivity. Reliability is supported by type checking at compile time, the support of exception handling, and a lack of aliasing. Naturalness for the application means the language provides appropriate data structures and control structures. Ease of program verification means that it can be proven correct easily. A good programming environment is supported by special editors, debugging tools, version control, and testing packages. Portability means a program written in one environment can be easily move to another environment. A well-defined description of the syntax and semantics would be supported by a good user manual. Generality means it is appropriate to use within a wide variety of applications. Cost to use depends upon the costs to: learn and train, create/write a program (time and labor), create a compiler (translator), compile the program, execute the program, and maintain a program. In addition, you must consider the cost of poor reliability.
									</p>
								</li>
								<li>
									<h3>
										What are the influences on language design?
									</h3>
									<p>
										Influences on language design include computer architecture (such as von Neumann's) as well as programming design methodologies (such as the shift from procedural oriented to data oriented and the shift from structure oriented to object oriented)
									</p>
								</li>
								<li>
									<h3>
										What are the 4 language categories and describe each?
									</h3>
									<p>
										The four language categories are imperative, functional, logic, and object-oriented. Imperative languages depend on changes to the contents of memory. Functional languages depend on the application of functions. Logic languages depend on the application of programming logic. Object-oriented languages depend on the definition and creation of instances of objects along with messages sent to those objects
									</p>
								</li>
								<li>
									<h3>
										What are language tradeoffs? Describe some examples of tradeoffs.
									</h3>
									<p>
										Language tradeoffs are decisions that must be made concerning what is most important when designing a language. Examples include reliability vs the cost of execution, writeability vs readability, and writeability vs reliability.
									</p>
								</li>
								<li>
									<h3>
										What does it mean to implement a programming language? Discuss the four methods of implementation.
									</h3>
									<p>
										Implementing a programming language means the construction of a translator (generally a compiler or interpreter). One method of implementation is pure compilation in which the source program written in a programming language is submitted to compiler to be translated into an equivalent object program in a target language, usually machine code. A second method is pure interpretation in which the interpreter acts as a software simulator for the machine running the program. This aides interactivity. A third method is hybrid interpretation in which the hybrid interpreter performs the first steps as does a compiler (lexical, syntactic, and intermediate code generation) which is then given to a simpler interpreter. A fourth method is using a preprocessor(macro processor) in which the source program is first given to the preprocessor which recognizes the definition and expansion of macros before it is given to a compiler.
									</p>
								</li>
								<li>
									<h3>
										Discuss tools that can be found in a programming environment and list examples of programming environment
									</h3>
									<p>
										Programming environments include tools for translation, debugging, and pretty printing. Examples of environments include UNIX, Borland JBuilder, Microsoft Visual Studio's .NET, and Netbeans.
									</p>
								</li>
							</ol>
							<h2 id="chapter2">Chapter 2</h2>
							<ol>
								<li>
									<h3>
										Discuss the history of FORTRAN.
									</h3>
									<p>
										FORTRAN was created by a team led by John Backus who wanted to develop a high level language for the IBM 704 environment. The first version, FORTRAN 0, came out in 1954. Variable names were limited to 2 characters. It had one counter controlled loop that was post-test. FORTRAN I came about between 55-57. It took 18 worker years to create, had variable names limited to 6 characters, implicit typing, and integer and real types. FORTRAN II came out in 1958. It had independent compilation for subprograms. FORTRAN IV came out between 60-62. It had explicit type declarations, a logical IF, and a semi-fixed field format. FORTRAN 77 came out in 1978 and added complex number type, character strings, and the IF/ELSE statement. To this point, FORTRAN was semi-fixed field, non-recursive, had no dynamic storage allocation, and no pointers. However, it was very execution efficient. Fortran 90 came out in 1990 and added recursion, pointers, CASE statement, dynamically allocated arrays, and removed fixed format. Fortran 95 came out in 97 and added the FORALL construct to support parallel execution on arrays (parallel processing). Fortran 2003 came out in 2004 and added object-oriented programming, parametrized derived types, procedure pointers, and interoperability with C. Fortran 2008 came out in 2010 and added blocks for local scope, co-arrays for concurrency, and the DO CONCURRENT statement. FORTRAN intially succeeded because IBM backed it, it allowed for highly optimized compilation, and it had strong support for scientific functions.
									</p>
								</li>
								<li>
									<h3>
										What did PL1 inherit from its parents?
									</h3>
									<p>
										It inherited separate compilation and the common keyword from FORTRAN. It inherited records, report generation, and I/O from COBOL. It inherited recursion and the block structure from ALGOL
									</p>
								</li>
								<li>
									<h3>
										Why should ALGOL have survived and for what reasons did it not?
									</h3>
									<p>
										ALGOL should have survived because an international committee created it, it was machine independent, and its syntax was formally described. It did not survive because it was too flexible, had a lack of I/O support, and no commercial support.
									</p>
								</li>
							</ol>
							<h2 id="chapter3">Chapter 3</h2>
							<ol>
								<li>
									<h3>
										Discuss the two methods for formally defining a programming language.
									</h3>
									<p>
										The two methods for formally defining a programming language are a language recognizer and a language generator. A language recognizer gets fed a program and recognizes a valid sentence in the language. An example would be a syntactic analyzer or a parser. A language generator starts from scratch and builds a program. An example would be a grammar for a language.
									</p>
								</li>
								<li>
									<h3>
										Describe the 4 elements of a grammar.
									</h3>
									<p>
										A grammar is made up of a 4-tuple (N, T, P, S) where N is a set of non-terminals to be defined further, T is a set of terminals or tokens, P is a set of production rules, and S is a start symbol that is an element of N. Furthermore, a grammar is a formal method of defining the syntax of a programming language with the rules specifying the sequence of tokens or lexemes. A grammar is also a language generator
									</p>
								</li>
								<li>
									<h3>
										Discuss the Chomsky hierarchy.
									</h3>
									<p>
										The Chomsky hierarchy was developed by Noam Chomsky in the 1950s as a means for analyzing the syntax of languages. Given a grammar with: A and B elements of N, a and b elements of T, and &alpha;, &beta;, &sigma;, and &tau; elements of N &cup; T, the following chart can be used to described the Chomsky Hierachy. Note that type 3 is a subset of type 2 is a subset of type 1 is a subset of type 0.
										<table class="table table-bordered">
											<th>Language Type</th>
											<th>Language Generator (or grammar)</th>
											<th>Language Recognizer (or automaton)</th>
											<th>Type of Grammar Rules</th>
											<tr>
												<td>3 Regular Language</td>
												<td>Regular Grammar</td>
												<td>Finite State Automaton (or Finite State Machine)</td>
												<td>A &rarr; a <br /> or <br /> A &rarr; bB</td>
											</tr>
											<tr>
												<td>2 Context Free Language</td>
												<td>Context-Free Grammar</td>
												<td>Push-down Automaton</td>
												<td>A &rarr; &alpha; <br /> A &rarr; abB <br /> A &rarr; aaaBa </td>
											</tr>
											<tr>
												<td>1 Context Sensitive Language</td>
												<td>Context-Sensitive Grammar</td>
												<td>Linear Bounded Automaton</td>
												<td>&alpha;&sigma;&beta; &rarr; &alpha;&tau;&beta;</td>
											</tr>
											<tr>
												<td>0 Recursively Enumerable</td>
												<td>Unrestricted Grammar</td>
												<td>Turing Machine</td>
												<td>&alpha; &rarr; &beta; <br /> &alpha; ≠ [empty]</td>
											</tr>
										</table>
									</p>
								</li>
								<li>
									<h3>
										Discuss the methods for formally expressing the semantics of a programming language.
									</h3>
									<p>
										The three methods for expressing the semantics of a programming language are operational semantics, denotational semantics (applicative), and axiomatic semantics. Operational semantics define how a program works related to a virtual machine and are useful for designing a compiler or for a programmer in general. An example would be the Vienna Definition Language. Denotational semantics construct a definition for a program and are useful for compiler designers only. Axiomatic semantics define the semantics as axioms or rules of inference and can be used to prove a program is logically correct.
									</p>
								</li>
								<li>
									<h3>
										Describe syntactic elements of a programming language which is not always evident in BNF or syntax diagrams.
									</h3>
									<p>
										There are 12 elements we have discussed for syntactic elements. The first element is the character set which is a set of symbols used to create identifiers, literals, reserve words, etc.. The second element is identifier rules for forming names by answering what must it begin with?, what can it contain?, and how long?. The third, fourth and fifth elements are dealing with operator symbols, keywords vs reserved words, and does it have noise words. Comments are the next element where commenting is special for a line or paragraph. Blank usage and delimiters are two other elements we discussed. You can have ignored blanks, separator blanks, or operator blanks and delimiters are simply grouping symbols. Another syntactic element is the formatting of lines in free, fixed, or semi-fixed. We have also discussed expressions and statement formats. In expressions, you can use prefix (+ A B), infix (A + B), or postfix (A B +), in any combination. In statement formats, you can have one basic format like SNOBOL, similar but different, diverse formats, or nested statements or not. The last element of the syntactic elements we discussed is the program/subprogram structure. We identify separate subprogram definitions, separate data definitions, nested subprogram definitions (Pascal), separate interface definitions (ADA), separate data and executable sections (COBOL), and unseparated (SNOBOL).
									</p>
								</li>
							</ol>
							<h2 id="chapter5">Chapter 5</h2>
							<ol>
								<li>
									<h3>
										Discuss and list two important concepts related to binding and data objects?
									</h3>

									<p>
										<ol>
											<li>
												Scope is a range of statements where a variable is known (visible) and useable (can be referenced). Scope can have global, non-local, or local variables. There are two rules associated with scope, static scoping rule and dynamic scoping rule. The static scoping rule associate with a reference to a variable the declaration of the variable occurring in the innermost block textually containing the reference, while dynamic scoping rule uses the most recently invoked, not yet terminated subprogram.
											</li>
											<li>
												Lifetime or extent is the time between allocation and deallocation of the storage bound to a data object. There are four categories for lifetime we have discussed. The first category is for static variables, which allocates storage before execution begins and deallocation after termination. An advantage of static variables is efficiency of execution and a disadvantage is cannot reuse storage. The second is stack-dynamic variables or allocation of storage at declaration elaboration and then deallocated when the subprogram terminates. An advantage is the ability to implement recursion and disadvantage is runtime overhead.The third category is explicit heap-dynamic variables. This is where nameless memory cells allocated/deallocated from the heap and referenced by pointers with instruction/function supplied by the language to allocate/deallocate. An advantage is the ability to create dynamic data structures and a disadvantage would be the complexity. The final category is implicit heap dynamic variables and is defined when allocation occurs when a value is assigned to a variable. An advantage would be flexibility and disadvantage is error detection is hard for translator.
											</li>
										</ol>
									</p>
								</li>
								<li>
									<h3>
										Given the following code, determine the static scoping rule and dynamic coping rule output.
									</h3>
									<p>
<pre><code>
BEGIN
	boolean b := true
	PROCEDURE P
		print (b)
END
BEGIN
	boolean b := false
	CALL P
END
</pre></code>
										Static Scoping prints <code>true</code>
										<br>
										Dynamic Scoping prints <code>false</code>
									</p>
								</li>
								<li>
									<h3>
										List and describe two methods for implementing static scoping rule and two for dynamic scoping rule.
									</h3>
									<p>
										<h4>Static Scoping</h4>
										<ol>
											<li>
												Static Pointer Method - replace the reference to a variable with an ordered pair (I,J) where I = number of pointer traversals (within the stack of activation records) and J = offset within the block containing the declaration for the variable. Each activation record on the stack has a pointer to the next textually containing block.
											</li>
											<li>
												Display Method - replace the reference to a variable with an ordered pair (I,J) where I = index in a display stack (stack of pointers) and J = offset within the block where the display pointer points. It also uses a hidden stack as well as the stack of activation records.
											</li>
										</ol>
									</p>
								</li>
								<li>
									<h3>
										What kind of problems occur with scope and extent being different?
									</h3>
									<p>
										Extent exceeds scope:
<pre><code>
new(ptra);
ptra := ptrb
</pre></code>
									</p>
									<p>
										Scope exceeds extent:
<pre><code>
new(ptra);
ptrb := ptra;
dispose(ptra);
</pre></code>
									</p>
								</li>
							</ol>
							<h2 id="chapter6">Chapter 6</h2>
							<ol>
								<li>
									<h3>
										What are the different types of elementary data types?
									</h3>
									<p>
										Elementary data types include integers, subranges of integers, floating point (real) numbers, fixed point numbers, booleans, rational numbers, complex numbers, characters, and enumerations.
									</p>
								</li>
								<li>
									<h3>
										What are the different types of composite data types?
									</h3>
									<p>
										The two composite data types are character strings and pointers.
									</p>
								</li>
								<li>
									<h3>
										Discuss the specification of structured data types.
									</h3>
									<p>
										The specification of a structured data type is made up of its number of components, type of components, mechanism for selecting a component, maximum number of components, and organization of components of memory. The number of components could be a fixed number or variable number. The type of components could be homogeneous or heterogeneous. Mechanisms for selecting a components could be either brackets, parenthesis, or a dot. Maximum number of components deals with, for example, how many dimensions an array could have. Organization of components in memory deals with, for example, row major vs column major storage of elements in array.
									</p>
								</li>
								<li>
									<h3>
										Discuss the possible operations on structured data types.
									</h3>
									<p>
										Possible operations on structured data types include component selection, whole structure operations, insertion/deletion of elements, and the creation and deletion of the data type
									</p>
								</li>
								<li>
									<h3>
										What are the two ways structured data types can be implemented in memory?
									</h3>
									<p>
										Structured data types can be implemented using sequential storage or linked components stored in several locations (a linked list)
									</p>
								</li>
								<li>
									<h3>
										What is necessary for the declaration of structured data types
									</h3>
									<p>
										Type of the structure, number of dimensions/components/fields, subscripts/field names, and the type of each component are all important considerations when declaring a structured data type.
									</p>
								</li>
								<li>
									<h3>
										Describe the two type checking problems.
									</h3>
									<p>
										First, does a component exist or is there such a field by the specified name. Second, is the component of the expected type.
									</p>
								</li>
								<li>
									<h3>
										What are the different structured data types?
									</h3>
									<p>
										The different structured data types are vectors(one dimensional arrays), multi-dimensional arrays, records/structs, variant records, lists, and sets.
									</p>
								</li>
								<li>
									<h3>
										Give the the formula to find A[i,j] stored in row major form and then give the formula to find A[i,j] in column major form
									</h3>
									<p>
										The formula to find A[i,j] stored in row major form can abstractly be though of as:
										<br /><br />
										<code>
											Start address + [(# rows to skip)(width of each row) + (number in last row to skip)] * element size
										</code>
										<br /><br />
										For A[i,j] this would become:
										<br /><br />
										<code>
											&alpha; + [(i - LB<sub>1</sub>)(UB<sub>2</sub> - LB<sub>2</sub> + 1) + (j - LB<sub>2</sub>)] * E
										</code>
										<br /><br />
										<br /><br />
										The formula to find A[i,j] stored in column major form can abstractly be though of as:
										<br /><br />
										<code>
											Start address + [(# columns to skip)(length of each column) + (number in last column to skip)] * element size
										</code>
										<br /> <br />
										For A[i,j] this would become:
										<br /><br />
										<code>
											&alpha; + [(j - LB<sub>2</sub>)(UB<sub>1</sub> - LB<sub>1</sub> + 1) + (i - LB<sub>1</sub>)] * E
										</code>
										<br /> <br />
									</p>
								</li>
							</ol>
						</section>
						<hr>
						<section id="glossary">
							<!-- GLOSSARY GOES HERE -->
							<h1>Glossary</h1>
							<dl>
								<dt id="orthogonality">
									Orthogonality
								</dt>
									<dd>
										Attribute where the user has the ability to combine various features of a language with all possible combinations being meaningful
									</dd>
								<dt id="syntax">Syntax</dt>
									<dd>
										The description of the structure of sentences in a language.
									</dd>
								<dt id="semantics">Semantics</dt>
									<dd>
										The description of the meaning of the sentences of a language.
									</dd>
								<dt id="language-def">Language</dt>
									<dd>
										Set of strings of finite length made up of characters from a chosen fixed set (alphabet - usually a subset from the collating sequence used to code characters)
									</dd>
								<dt id="character-set">Character Set</dt>
									<dd>
										Symbols used to create identifiers, literals, reserve words, etc.
									</dd>
								<dt id="lexeme">Lexeme</dt>
									<dd>
										Smallest recognizable unit of a programming language (numeric literals, operators, special words, identifiers).
									</dd>
								<dt id="token">Token</dt>
									<dd>
										Category of lexemes
									</dd>
								<dt id="grammar">Grammar <small>Don't forget the "A-R" ending!</small></dt>
									<dd>
										A formal method of defining the syntax of a programming language with the rules specifying the sequence of tokens or lexemes.
									</dd>
								<dt id="ambiguous-grammar">Ambiguous Grammar</dt>
									<dd>
										A grammar in which at least one <a href="#sentence">sentence</a> may be represented by two or more distinct <a href="#parse-tree">parse trees</a>
									</dd>
								<dt id="attribute-grammar">Attribute Grammar</dt>
									<dd>
										Method of describing the syntax along with the static semantics. The meaning of the program is known at compile time.
									</dd>
								<dt id="metalanguage">Metalanguage</dt>
									<dd>
										Language used to describe another language
									</dd>
								<dt id="syntax-diagram">Syntax Diagram</dt>
									<dd>
										A graphical representation of the syntax using rectangles to enclose nonterminals, rounded shapes to enclose terminals with arrow connectors
									</dd>
								<dt id="derivation">Derivation</dt>
									<dd>
										Sequence of application of grammar rules of a language, beginning with the start symbol until you reach a string
									</dd>
								<dt id="sentential-form">Sentential Form</dt>
									<dd>
										One of the steps generated within a derivation.
									</dd>
								<dt id="sentence">Sentence</dt>
									<dd>
										The final sentential form containing only terminals.
									</dd>
								<dt id="parse-tree">Parse Tree</dt>
									<dd>
										Graphical representation or hierarchical structure of representing the steps in a derivation tree in reverse order
									</dd>
								<dt id="readability">
									Readability
								</dt>
									<dd>
										Clarity of a program in a language
									</dd>
								<dt id="writeability">
									Writeability
								</dt>
									<dd>
										Ease of creating a program in a programming language
									</dd>
								<dt id="reliability">
									Reliability
								</dt>
									<dd>
										A program performs to specifications under all conditions
									</dd>
								<dt id="portability">
									Portability
								</dt>
									<dd>
										The ease of moving a program written in one environment into another environment
									</dd>
								<dt id="keyword">
									Keyword
								</dt>
									<dd>
										Keywords are special identifiers which are available to be used for variable names as well.
									</dd>
								<dt id="reserveWord">
									Reserve Word
								</dt>
									<dd>
										Reserved words are special identifiers which <strong>cannot</strong> be redefined by the user
									</dd>
								<dt id="noiseWord">
									Noise Words
								</dt>
									<dd>
										Words which are not necessary but can be included to enhance readability
									</dd>
								<dt id="identifier">
									Identifiers
								</dt>
									<dd>
										Strings used to identify variables, constants, subprograms, etc.
									</dd>
								<dt id="expressivity">
									Expressivity
								</dt>
									<dd>
										Powerful operators and convenient methods for expressing common computation
									</dd>
								<dt id="exception">
									Exception
								</dt>
									<dd>
										A rare event which needs special consideration
									</dd>
								<dt id="aliasing">
									Aliasing
								</dt>
									<dd>
										The process of allowing two or more distinct names to refer to the same storage location
									</dd>
								<dt id="generality">Generality</dt>
									<dd>
										Appropriate to use within a wide variety of applications
									</dd>
								<dt id="support-of-abstraction">
									Support of Abstraction
								</dt>
									<dd>
										Ability to name an abstraction and then use it.
									</dd>
								<dt id="process-abstraction">
									Process Abstraction
								</dt>
									<dd>
										The creation and use of subprograms
									</dd>
								<dt id="data-abstraction">
									The creation and use of a new data type along with the operations on that data type
								</dt>
								<dt id="programming-environment">
									The programming environment can refer to any of the following which are specific to the language:
									<ul>
										<li>Code editor</li>
										<li>Debugging tools</li>
										<li>Version control</li>
										<li>Testing packages</li>
									</ul>
								</dt>
								<dt id="implementation">
									Implementation
								</dt>
									<dd>
										The process of constructing a translator for a language.
									</dd>
								<dt id="static-binding">Static Binding</dt>
									<dd>
										Occurs at compile time and is fixed.
									</dd>
								<dt id="dynamic-binding">Dynamic Binding</dt>
									<dd>
										Occurs during run time and changes.
									</dd>
								<dt id="declaration">Declaration</dt>
									<dd>Statement which "fixes" types with variables</dd>
								<dt id="type-checking">Type Checking</dt>
									<dd>
										Determining whether operations are receiving the correct type operands.
									</dd>
								<dt id="extent">
								<dt id="lifetime">
									Extent (Or Extent)
								</dt>
								</dt>
									<dd>
										Time between allocation and deallocation of the storage bound to a data object
									</dd>
								<dt id="static-variable">Static Variable</dt>
									<dd>
										Allocate storage before execution begins and deallocate when the program terminates
									</dd>
								<dt id="stack-dynamic-variable">Stack-Dynamic Variable</dt>
									<dd>
										Allocate storage when a declaration is elaborated but the type is static and then deallocated when the subprogram or block containing the declaration terminates. Allocation takes place from a run-time stack.
									</dd>
								<dt id="elaboration">Elaboration</dt>
									<dd>
										When execution reaches the code to which a declaration is attached
									</dd>
								<dt id="explicit-heap-dynamic-variable">Explicit Heap-Dynamic Variable</dt>
									<dd>
										Nameless memory cells allocated and deallocated from the heap section of memory set aside for the program, referenced by pointers with some instruction or function supplied by the language to allocate (new or alloc) and to deallocate (free or dispose)
									</dd>
								<dt id="implicit-heap-dynamic-variable">Implicit Heap-Dynamic Variable</dt>
									<dd>
										Allocation occurs when a value is assigned to a variable
									</dd>
								<dt id="scope">Scope</dt>
									<dd>
										Range of statements where a variable is known (visible) and hence usable (can be referenced)
									</dd>
								<dt id="global-scope">Global Scope</dt>
									<dd>
										Declared within the main program and visible to entire program.
									</dd>
								<dt id="non-local-scope">Non-Local Scope</dt>
									<dd>
										Variable which is not global and not declared within a subprogram, but visible to the subprogram
									</dd>
								<dt id="local-scope">Local Scope</dt>
									<dd>
										Variable declared within the currently executing block.
									</dd>
								<dt id="activation-record">Activation Record</dt>
									<dd>
									 	A data structure containing the variables belonging to one particular scope (e.g. a procedure body), as well as links to other activation records.
										<br>
										Activation records are usually created (on the stack) on entry to a block and destroyed on exit. If a procedure or function may be returned as a result, stored in a variable and used in an outer scope then its activation record must be stored in a heap so that its variables still exist when it is used. Variables in the current scope are accessed via the frame pointer which points to the current activation record. Variables in an outer scope are accessed by following chains of links between activation records. There are two kinds of link - the static link and the dynamic link.

									</dd>
								<dt id="static-scoping-rule">Static Scoping Rule</dt>
									<dd>
										Replace the reference to a variable with an ordered pair <code>(I,J</code> where <code>I = [number of pointer traversals within the stack of activation records]</code> and <code>J = [offset within the block containing the declaration for the variable]</code>. Each activation record on the stack has a pointer pointing to the next textually containing block.
									</dd>
								<dt id="display-method">Display Method</dt>
									<dd>
										Replace the reference to a variable with an ordered pair <code>(I,J)</code> where <code>I = [index in a display stack (stack of pointers)]</code> and <code>J = [offset within the block where the display pointer points]</code>. It also uses a hidden stack as well as the stack of activation records.
									</dd>
								<dt id="cret">CRET <small>Current Referencing Environment Table</small></dt>
									<dd>
										Maintain a dynamic symbol table holding symbols, whether active, and a pointer to where they are located within the stack of activation records.
										<div class="example">
											<small>(The way she wants it also represents the function stack.)</small>
											<table class="table table-bordered table-striped">
												<tr>
													<th>Symbol</th>
													<th>Active</th>
													<th>Pointer to Location</th>
												</tr>
												<tr>
													<td>i</td>
													<td>T</td>
													<td><code>&uarr; MAIN</code></td>
												</tr>
												<tr>
													<td>j</td>
													<td>T</td>
													<td><code>&uarr; A</code></td>
												</tr>
												<tr>
													<td>x</td>
													<td>F</td>
													<td><code>&uarr; NULL</code></td>
												</tr>
												<tr>
													<td>y</td>
													<td>T</td>
													<td><code>&uarr; A</code></td>
												</tr>
												<tr>
													<td>z</td>
													<td>T</td>
													<td><code>&uarr; B</code></td>
												</tr>
											</table>
										</div>
									</dd>
								<dt id="referencing-environment">Referencing Environment</dt>
									<dd>
										Set of all variables visible (having scope) for an executing statement
									</dd>
								<dt class="runtime-descriptor">Runtime Descriptor</dt>
									<dd>
										Used to keep up with possible array indices of a vector (array) and consists of the name, address, lower bound, upper bound, and data type.
									</dd>
							</dl>
							<!-- END GLOSSARY SECTION -->
						</section>
						<hr>
						<section id="languages">
							<!-- LANGUAGE SPECIFIIC NOTES GO HERE -->
							<h1>Languages</h1>
							<h2 id="fortran">FORTRAN</h2>
							<ul>
								<li>
									FORTRAN 0
									<ul>
										<li>Variable names were 2 characters</li>
										<li>Counter controlled loop was post-test</li>
									</ul>
								</li>
								<li>
									FORTRAN 1
									<ul>
										<li>10 worker years to create</li>
										<li>Variable names were 6 characters</li>
										<li>Implicit typing</li>
									</ul>
								</li>
								<li>
									FORTRAN 2
									<ul>
										<li>Independent compilation for subprograms</li>
										<li>Explicit type declarations</li>
										<li>Semi-fixed fields</li>
										<li>Added logical <code>IF</code></li>
									</ul>
								</li>
								<li>
									FORTRAN 77
									<ul>
										<li>Added character strings and <code>IF ELSE</code></li>
									</ul>
								</li>
								<li>
									Fortran 90
									<ul>
										<li>Added recursion, pointers, CASE, dynamically allocated arrays, removed fixed format</li>
									</ul>
								</li>
								<li>
									Fortran 95
									<ul>
										<li>Added <code>FORALL</code> construct to support making parallel execution on an array</li>
									</ul>
								</li>
								<li>
									Fortran 2003
									<ul>
										<li>Added OO Programming and parameterized derived types procedure pointers and interoperability with C</li>
									</ul>
								</li>
								<li>
									Fortran 2010
									<ul>
										<li>Added blocks for local scope, co-arrays and the <code>DO CONCURRENT</code></li>
									</ul>
								</li>
							</ul>
							<!-- END LANGUAGES SECTION -->
						</section>
						<hr>
						<a href="#sample-test1" class="btn btn-success purple btn-lg btn-block" onclick="showStuff();">Pictures of Kittens!</a>
						<section id="sample-test1" class="sample-test">
							<h1>CS 410 Midterm - Fall 2012</h1>
							<p>
								Complete in pencil. Write only on one side of your paper. Place your name at the top of each page. Fold your papers with the answers arranged in numerical order along with this test.
							</p>
							<ol>
								<li>
									Define the following:
									<ol>
										<li>Syntax</li>
										<li>Scope</li>
										<li>Semantics</li>
										<li>Orthogonality</li>
										<li>Lexeme</li>
										<li>Imperative Language</li>
										<li>Synthesized Attribute</li>
										<li>Sentence</li>
										<li>Derivation</li>
										<li>Metalanguage</li>
									</ol>
								</li>
								<li>
									Discuss features of the syntax of a programming language which can greatly influence the readability of a program.
								</li>
								<li>
									Discuss five characteristics of a "good" programming language and give examples of languages possessing each characteristic.
								</li>
								<li>
									Define ambiguous grammar and give an example of a grammar which is ambiguous and demonstrate with a sentence.
								</li>
								<li>
									Using the statement <code>A := 7 + B</code>, discuss the different binding times within the life of a programming language.
								</li>
								<li>
									Discuss the <a href="index.html#chomsky">Chomsky Hierarchy</a>.
								</li>
								<li>
									Demonstrate the <a href="#dynamic-scoping-rule">Dynamic Scoping Rule</a> for the following:
									<br>
<pre>
<code>MAIN</code> calls <code>X</code> which calls <code>Y</code> which calls <code>Z</code> and after <code>Z</code> terminates, also then calls <code>W</code>.
<code>MAIN</code> has variables a, b, and c.
<code>W</code> has variables e and f.
<code>X</code> has variables b and d.
<code>Y</code> has variables a, c, and e.
<code>Z</code> has variables c and f.
</pre>
								</li>
								<li>
									Discuss the three different methods for formally describing the semantics of a programming language.
								</li>
								<li>
									Discuss the different methods for implementing the static scoping rule and demonstrate one method on the following code. [Sample code unavailable]
								</li>
							</ol>
						</section>
						<section id="sample-test2" class="sample-test">
							<h1>CS 410 Midterm - [Date Unknown]</h1>
							<p>
								Complete in pencil. Write only on one side of your paper. Place your name at the top of each page. Fold your papers with the answers arranged in numerical order along with this test.
							</p>
							<ol>
								<li>
									Define the following:
									<ol>
										<li>Syntax</li>
										<li>Scope</li>
										<li>Semantics</li>
										<li>Orthogonality</li>
										<li>Lexeme</li>
										<li>Imperative Language</li>
										<li>Data Object</li>
										<li>Sentence</li>
										<li>Derivation</li>
										<li>Metalanguage</li>
									</ol>
								</li>
								<li>
									Give an example of a language for each of the following:
									<ol>
										<li>Designed for simplicity</li>
										<li>Designed for embedded systems</li>
										<li>Normally interpreted</li>
										<li>Supports ease of text handling</li>
										<li>Uses static scoping rule</li>
										<li>Uses noise words</li>
										<li>Applicative language</li>
										<li>Rule based language</li>
										<li>Descendant of ALGOL</li>
										<li>Complex number data type</li>
									</ol>
								</li>
								<li>
									Discuss features of the syntax of a programming language which can greatly influence the readability of a program.
								</li>
								<li>
									Discuss four characteristics of a "good" language and give examples of languages possessing each characterisitic.
								</li>
								<li>Define ambiguous grammar and give an example of a grammar which is ambiguous and demonstrate it with a sentence.</li>
								<li>
									Using the statement <code>X := 3 / Y</code>, discuss the different binding times within the life of a programming language.
								</li>
								<li>
									Discuss the steps within the compilation process.
								</li>
								<li>
									Discuss the different methods for implementing the static scoping rule and demonstrate one method on the following code:
<pre><code>
PROGRAM A
	PROCEDURE P
		BEGIN (Procedure P)
			.
			.
		END (Procedure P)
		Procedure B
			Procedure C
					.
					.
					.
				BEGIN (Procedure C)
					.
					CALL P
				END (Procedure C)
			BEGIN (Procedure B)
				.
				.
				CALL P
				CALL C
			END (Procedure B)
	BEGIN (Main)
		CALL B
	END. (Main)
</pre></code>
								</li>
								<li>
									Demonstrate the dynamic scoping rule for the following:
<pre>
<code>MAIN</code> calls <code>J</code> which calls <code>K</code> which calls <code>L</code> and also then calls <code>M</code>.
<code>MAIN</code>has variables <code>a</code>, <code>b</code>, and <code>c</code>
<code>J</code> has variables <code>b</code> and <code>d</code>
<code>K</code> has variables <code>a</code>, <code>c</code>, and <code>e</code>
<code>L</code> has variables <code>c</code> and <code>f</code>
<code>M</code> has variables <code>a</code> and <code>e</code>
</pre>
								</li>
								<li>
									Given the following grammar rules, determine whether the strings <code>([x,y])</code> and <code>[y]</code> are valid strings in the language. If valid, demonstrate with a leftmost derivation and a parse tree.
<pre><code>
&lt;pop&gt;	::= [ &lt;bop&gt; , &lt;pop&gt; ]
&lt;pop&gt;	::= &lt;bop&gt;
&lt;bop&gt;	::= &lt;boop&gt;
&lt;bop&gt;	::= ( &lt;pop&gt; )
&lt;boop&gt;	::= x | y | z
</pre></code>
								</li>
							</ol>
						</section>
						<section id="sample-test3" class="sample-test">
							<h1>CS 410 Midterm - Fall 2008</h1>
							<p>
								Complete in pencil. Write only on one side of your paper. Place your name at the top of each page. Fold your papers with the answers arranged in numerical order along with this test.
							</p>
							<ol>
								<li>
									Define the following:
									<ol>
										<li>Syntax</li>
										<li>Scope</li>
										<li>Semantics</li>
										<li>Reliability</li>
										<li>Extent</li>
										<li>Ambiguous Grammar</li>
										<li>Data Object</li>
										<li>Sentential Form</li>
										<li>Parse Tree</li>
										<li>Metalanguage</li>
									</ol>
								</li>
								<li>
									Give an example of a language for each of the following:
									<ol>
										<li>Designed for ease of learning</li>
										<li>Orthogonality</li>
										<li>First language to support recursion</li>
										<li>Ease of proving programs correct</li>
										<li>Uses prefix notation for expressions</li>
										<li>Uses noise words</li>
										<li>Applicative language</li>
										<li>Imperative language</li>
										<li>Descendant of ALGOL</li>
										<li>Complex number data type</li>
									</ol>
								</li>
								<li>
									List five reasons for studying programming languages.
								</li>
								<li>
									Discuss five characteristics of a "good" language and give examples of languages possessing each characteristic.
								</li>
								<li>
									<span class="important">Discuss the problems which may occur when the scope and extent are not in the correct relationship. Give example code to demonstrate.</span>
								</li>
								<li>
									List and discuss the possible binding times in the life of a programming language and give an example of something which might be bound.
								</li>
								<li>
									Discuss different areas of cost within the use of a programming language and give an example of a language that has a low cost in each area.
								</li>
								<li>
									Discuss the different methods for determining the type equivalence and demonstrate using the following declarations:
<pre><code>
TYPE
	X = ARRAY [1..12] OF INTEGER;
	Y = ( RED, YELLOW, GREEN, BLUE);
	Z = Y;
VAR
	A,B:REAL;
	C:REAL;
	D,E : X;
	F: Y;
	G,H: ARRAY [1..12] OF INTEGER;
	J: Z;
</pre></code>
								</li>
								<li>
									Discuss the different methods for implementing the static scoping rule and demonstrate one method on the following code:
<pre><code>
PROGRAM MAIN
	PROCEDURE A
		BEGIN (Procedure A)
			.
			.
		END (Procedure A)
	PROCEDURE B
		PROCEDURE C
			PROCEDURE D
				BEGIN (Procedure D)
					.
					.
					CALL A
				END (Procedure D)
			BEGIN (Procedure C)
				.
				.
				CALL D
			END (Procedure C)
		BEGIN (Procedure B)
			.
			.
			CALL C
		END (Procedure B)
	BEGIN (Main)
		CALL A
		CALL B
	END. (Main)
</pre></code>
								</li>
								<li>
									Demonstrate the dynamic scoping rule for the following:
<pre>
<code>MAIN</code> calls <code>A</code> which calls <code>B</code> which calls <code>C</code>.
<code>MAIN</code> has variables <code>x</code>, <code>y</code>, and <code>z</code>.
<code>A</code> has variables <code>w</code> and <code>x</code>.
<code>B</code> has variables <code>v</code>, <code>w</code>, and <code>y</code>.
<code>C</code> has variables <code>u</code> and <code>z</code>.
</pre>
								</li>
								<li>
									Given the following grammar rules, determine whether the strings <code>aabbbcc</code> and <code>abbc</code> are valid strings in the language. If valid, demonstrate with a leftmost derivation and a parse tree.
<pre><code>
&lt;A&gt; ::= a &lt;A&gt;
&lt;A&gt; ::= b &lt;B&gt;
&lt;A&gt; ::= a
&lt;B&gt; ::= b &lt;B&gt;
&lt;B&gt; ::= b &lt;C&gt;
&lt;C&gt; ::= c &lt;C&gt;
&lt;C&gt; ::= c
</pre></code>
								</li>
							</ol>
							<div class="container">
								<h2>You made it!</h2>
								<img src="http://placekitten.com/g/800/600" alt="D'aww!">
							</div>
						</section>
					</div>
				</div>
			</div>
		<!-- </div> -->
	</body>
	<script src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js" ></script>
	<script>
	function showStuff(){
		$('.sample-test').toggle();
	}
	</script>
</html>