<!DOCTYPE html>
<html>
	<head>
		<title>Programming Languages Notes</title>
		<meta charset="UTF-8">
		<link rel="stylesheet" href="css/bootstrap.css" />
		<link rel="stylesheet" href="css/example.css" />
		<link rel="stylesheet" href="css/aside.css">
		<link rel="stylesheet" href="css/question.css">
		<link rel="stylesheet" type="text/css" charset="utf-8" href="css/style.css" />
		<script src="js/require.js"></script>
		<script src="js/jquery-1.8.2.min.js"></script>
		<script src="js/showdown.js"></script>
	</head>
	<body>
		<div class="container">
			<div class="row">
				<div class="hero-unit">
					<h1 class="title">CS 410W - Programming Languages</h1>
				</div>
				<div class="col-lg-3">
					<div data-spy="affix" class="TOContents affix" id="TOC">
						<h1>Table of Contents</h1>
						<ul>
							<li>
								<a href="#test-questions">Test Questions</a>
								<ul>
									<li><a href="#chapter1">Chapter 1</a></li>
									<li><a href="#chapter2">Chapter 2</a></li>
									<li><a href="#chapter3">Chapter 3</a></li>
									<li><a href="#chapter5">Chapter 5</a></li>
									<li><a href="#chapter6">Chapter 6</a></li>
								</ul>
							</li>
							<li><a href="#glossary">Glossary</a></li>
							<li>
								<a href="#languages">Languages</a>
								<ul>

								</ul>
							</li>
							<li><a href="#sample-test">Sample Test</a></li>
						</ul>
						<a href="index.html" class="btn btn-success btn-lg btn-block">Back to Notes</a>
					</div>
					<div data-spy="affix" id="todo-list" class="todo affix">
						<div markdown="1">
							<script>
								var todoMD = $().load('Todo.mdown').text();
								// var todoMD = todoMD.text();
								var converter = new Showdown.converter();
								var todoHTML = converter.makeHtml(todoMD);
								$('#todo-list').html(todoHTML);
								// document.write()
							</script>
						</div>
					</div>
				</div>
				<div class="col-lg-9">
					<div class="content">
						<section id="test-questions">
							<h2 id="chapter1">Chapter 1</h2>
							<ol>
								<li>
									<h3>
										Why should someone study programming 	languages?
									</h3>
									<p>
										Studying programming languages is beneficial in that it aids in learning new languages, increases our language vocabulary, improves our algorithm development, aids in the design of new languages, aids in the choice of a language to use to implement a project, increases our understanding of the languages we currently use, and encourages the survival of "good" languages and the extinction of "bad" languages.
									</p>
								</li>
								<li>
									<h3>
										What are the differences between high level and low level languages?
									</h3>
									<p>
										High level languages are generally very readable (use English like words), translated by a compiler or interpreter, very powerful, and have a one to many translation rate. On the other hand, low level languages are not very readable, must be translated by an assembler, very efficient, and have a one to one translation rate
									</p>
								</li>
								<li>
									<h3>
										What are the attributes of a "good" programming language? Discuss the details of each attribute.
									</h3>
									<p>
										The attributes of a good programming language are readability/clarity, write-ability, reliability, naturalness for the application, ease of program verification, a good programming environment, portability, a well-defined description of the syntax and semantics, generality, and low cost of use. Readability is supported by overall simplicity (small set of language construct), lack of feature multiplicity (redundancy), lack of operator overloading, orthogonality, adequate data structures and data types provided by the language, and a syntax which is readable. Syntax features which increase usability are the use of reserved words and the inclusion of noise words. Write-ability or the ease of creating a program is supported by simplicity, orthogonality, support of abstraction, and expressivity. Reliability is supported by type checking at compile time, the support of exception handling, and a lack of aliasing. Naturalness for the application means the language provides appropriate data structures and control structures. Ease of program verification means that it can be proven correct easily. A good programming environment is supported by special editors, debugging tools, version control, and testing packages. Portability means a program written in one environment can be easily move to another environment. A well-defined description of the syntax and semantics would be supported by a good user manual. Generality means it is appropriate to use within a wide variety of applications. Cost to use depends upon the costs to: learn and train, create/write a program (time and labor), create a compiler (translator), compile the program, execute the program, and maintain a program. In addition, you must consider the cost of poor reliability.
									</p>
								</li>
								<li>
									<h3>
										What are the influences on language design?
									</h3>
									<p>
										Influences on language design include computer architecture (such as von Neumann's) as well as programming design methodologies (such as the shift from procedural oriented to data oriented and the shift from structure oriented to object oriented)
									</p>
								</li>
								<li>
									<h3>
										What are the 4 language categories and describe each?
									</h3>
									<p>
										The four language categories are imperative, functional, logic, and object-oriented. Imperative languages depend on changes to the contents of memory. Functional languages depend on the application of functions. Logic languages depend on the application of programming logic. Object-oriented languages depend on the definition and creation of instances of objects along with messages sent to those objects
									</p>
								</li>
								<li>
									<h3>
										What are language tradeoffs? Describe some examples of tradeoffs.
									</h3>
									<p>
										Language tradeoffs are decisions that must be made concerning what is most important when designing a language. Examples include reliability vs the cost of execution, writeability vs readability, and writeability vs reliability.
									</p>
								</li>
								<li>
									<h3>
										What does it mean to implement a programming language? Discuss the four methods of implementation.
									</h3>
									<p>
										Implementing a programming language means the construction of a translator (generally a compiler or interpreter). One method of implementation is pure compilation in which the source program written in a programming language is submitted to compiler to be translated into an equivalent object program in a target language, usually machine code. A second method is pure interpretation in which the interpreter acts as a software simulator for the machine running the program. This aides interactivity. A third method is hybrid interpretation in which the hybrid interpreter performs the first steps as does a compiler (lexical, syntactic, and intermediate code generation) which is then given to a simpler interpreter. A fourth method is using a preprocessor(macro processor) in which the source program is first given to the preprocessor which recognizes the definition and expansion of macros before it is given to a compiler.
									</p>
								</li>
								<li>
									<h3>
										Discuss tools that can be found in a programming environment and list examples of programming environment
									</h3>
									<p>
										Programming environments include tools for translation, debugging, and pretty printing. Examples of environments include UNIX, Borland JBuilder, Microsoft Visual Studio's .NET, and Netbeans.
									</p>
								</li>
							</ol>
							<h2 id="chapter2">Chapter 2</h2>
							<ol>
								<li>
									<h3>
										Discuss the history of FORTRAN.
									</h3>
									<p>
										FORTRAN was created by a team led by John Backus who wanted to develop a high level language for the IBM 704 environment. The first version, FORTRAN 0, came out in 1954. Variable names were limited to 2 characters. It had one counter controlled loop that was post-test. FORTRAN I came about between 55-57. It took 18 worker years to create, had variable names limited to 6 characters, implicit typing, and integer and real types. FORTRAN II came out in 1958. It had independent compilation for subprograms. FORTRAN IV came out between 60-62. It had explicit type declarations, a logical IF, and a semi-fixed field format. FORTRAN 77 came out in 1978 and added complex number type, character strings, and the IF/ELSE statement. To this point, FORTRAN was semi-fixed field, non-recursive, had no dynamic storage allocation, and no pointers. However, it was very execution efficient. Fortran 90 came out in 1990 and added recursion, pointers, CASE statement, dynamically allocated arrays, and removed removed fixed format. Fortran 95 came out in 97 and added the FORALL construct to support parallel execution on arrays (parallel processing). Fortran 2003 came out in 2004 and added object-oriented programming, parametrized derived types, procedure pointers, and interoperability with C. Fortran 2008 came out in 2010 and added blocks for local scope, co-arrays for concurrency, and the DO CONCURRENT statement. FORTRAN intially succeeded because IBM backed it, it allowed for highly optimized compilation, and it had strong support for scientific functions.
									</p>
								</li>
							</ol>
						</section>
						<hr>
						<section id="glossary">
							<!-- GLOSSARY GOES HERE -->
							<h1>Glossary</h1>
							<dl>
								<dt id="orthogonality">
									Orthogonality
								</dt>
									<dd>
										Attribute where the user has the ability to combine various features of a language with all possible combinations being meaningful
									</dd>
								<dt id="syntax">Syntax</dt>
									<dd>
										The description of the structure of sentences in a language.
									</dd>
								<dt id="semantics">Semantics</dt>
									<dd>
										The description of the meaning of the sentences of a language.
									</dd>
								<dt id="language-def">Language</dt>
									<dd>
										Set of strings of finite length made up of characters from a chosen fixed set (alphabet - usually a subset from the collating sequence used to code characters)
									</dd>
								<dt id="character-set">Character Set</dt>
									<dd>
										Symbols used to create identifiers, literals, reserve words, etc.
									</dd>
								<dt id="lexeme">Lexeme</dt>
									<dd>
										Smallest recognizable unit of a programming language (numeric literals, operators, special words, identifiers).
									</dd>
								<dt id="token">Token</dt>
									<dd>
										Category of lexemes
									</dd>
								<dt id="grammar">Grammar <small>Don't forget the "A-R" ending!</small></dt>
									<dd>
										A formal method of defining the syntax of a programming language with the rules specifying the sequence of tokens or lexemes.
									</dd>
								<dt id="ambiguous-grammar">Ambiguous Grammar</dt>
									<dd>
										A grammar in which at least one <a href="#sentence">sentence</a> may be represented by two or more distinct <a href="#parse-tree">parse trees</a>
									</dd>
								<dt id="attribute-grammar">Attribute Grammar</dt>
									<dd>
										Method of describing the syntax along with the static semantics. The meaning of the program is known at compile time.
									</dd>
								<dt id="metalanguage">Metalanguage</dt>
									<dd>
										Language used to describe another language
									</dd>
								<dt id="syntax-diagram">Syntax Diagram</dt>
									<dd>
										A graphical representation of the syntax using rectangles to enclose nonterminals, rounded shapes to enclose terminals with arrow connectors
									</dd>
								<dt id="derivation">Derivation</dt>
									<dd>
										Sequence of application of grammar rules of a language, beginning with the start symbol until you reach a string
									</dd>
								<dt id="sentential-form">Sentential Form</dt>
									<dd>
										One of the steps generated within a derivation.
									</dd>
								<dt id="sentence">Sentence</dt>
									<dd>
										The final sentential form containing only terminals.
									</dd>
								<dt id="parse-tree">Parse Tree</dt>
									<dd>
										Graphical representation or hierarchical structure of representing the steps in a derivation tree in reverse order
									</dd>
								<dt id="readability">
									Readability
								</dt>
									<dd>
										Clarity of a program in a language
									</dd>
								<dt id="writeability">
									Writeability
								</dt>
									<dd>
										Ease of creating a program in a programming language
									</dd>
								<dt id="reliability">
									Reliability
								</dt>
									<dd>
										A program performs to specifications under all conditions
									</dd>
								<dt id="portability">
									Portability
								</dt>
									<dd>
										The ease of moving a program written in one environment into another environment
									</dd>
								<dt id="keyword">
									Keyword
								</dt>
									<dd>
										Keywords are special identifiers which are available to be used for variable names as well.
									</dd>
								<dt id="reserveWord">
									Reserve Word
								</dt>
									<dd>
										Reserved words are special identifiers which <strong>cannot</strong> be redefined by the user
									</dd>
								<dt id="noiseWord">
									Noise Words
								</dt>
									<dd>
										Words which are not necessary but can be included to enhance readability
									</dd>
								<dt id="identifier">
									Identifiers
								</dt>
									<dd>
										Strings used to identify variables, constants, subprograms, etc.
									</dd>
								<dt id="expressivity">
									Expressivity
								</dt>
									<dd>
										Powerful operators and convenient methods for expressing common computation
									</dd>
								<dt id="exception">
									Exception
								</dt>
									<dd>
										A rare event which needs special consideration
									</dd>
								<dt id="aliasing">
									Aliasing
								</dt>
									<dd>
										The process of allowing two or more distinct names to refer to the same storage location
									</dd>
								<dt id="generality">Generality</dt>
									<dd>
										Appropriate to use within a wide variety of applications
									</dd>
								<dt id="support-of-abstraction">
									Support of Abstraction
								</dt>
									<dd>
										Ability to name an abstraction and then use it.
									</dd>
								<dt id="process-abstraction">
									Process Abstraction
								</dt>
									<dd>
										The creation and use of subprograms
									</dd>
								<dt id="data-abstraction">
									The creation and use of a new data type along with the operations on that data type
								</dt>
								<dt id="programming-environment">
									The programming environment can refer to any of the following which are specific to the language:
									<ul>
										<li>Code editor</li>
										<li>Debugging tools</li>
										<li>Version control</li>
										<li>Testing packages</li>
									</ul>
								</dt>
								<dt id="implementation">
									Implementation
								</dt>
									<dd>
										The process of constructing a translator for a language.
									</dd>
								<dt id="static-binding">Static Binding</dt>
									<dd>
										Occurs at compile time and is fixed.
									</dd>
								<dt id="dynamic-binding">Dynamic Binding</dt>
									<dd>
										Occurs during run time and changes.
									</dd>
								<dt id="declaration">Declaration</dt>
									<dd>Statement which "fixes" types with variables</dd>
								<dt id="type-checking">Type Checking</dt>
									<dd>
										Determining whether operations are receiving the correct type operands.
									</dd>
								<dt id="extent">
								<dt id="lifetime">
									Extent (Or Extent)
								</dt>
								</dt>
									<dd>
										Time between allocation and deallocation of the storage bound to a data object
									</dd>
								<dt id="static-variable">Static Variable</dt>
									<dd>
										Allocate storage before execution begins and deallocate when the program terminates
									</dd>
								<dt id="stack-dynamic-variable">Stack-Dynamic Variable</dt>
									<dd>
										Allocate storage when a declaration is elaborated but the type is static and then deallocated when the subprogram or block containing the declaration terminates. Allocation takes place from a run-time stack.
									</dd>
								<dt id="elaboration">Elaboration</dt>
									<dd>
										When execution reaches the code to which a declaration is attached
									</dd>
								<dt id="explicit-heap-dynamic-variable">Explicit Heap-Dynamic Variable</dt>
									<dd>
										Nameless memory cells allocated and deallocated from the heap section of memory set aside for the program, referenced by pointers with some instruction or function supplied by the language to allocate (new or alloc) and to deallocate (free or dispose)
									</dd>
								<dt id="implicit-heap-dynamic-variable">Implicit Heap-Dynamic Variable</dt>
									<dd>
										Allocation occurs when a value is assigned to a variable
									</dd>
								<dt id="scope">Scope</dt>
									<dd>
										Range of statements where a variable is known (visible) and hence usable (can be referenced)
									</dd>
								<dt id="global-scope">Global Scope</dt>
									<dd>
										Declared within the main program and visible to entire program.
									</dd>
								<dt id="non-local-scope">Non-Local Scope</dt>
									<dd>
										Variable which is not global and not declared within a subprogram, but visible to the subprogram
									</dd>
								<dt id="local-scope">Local Scope</dt>
									<dd>
										Variable declared within the currently executing block.
									</dd>
								<dt id="activation-record">Activation Record</dt>
									<dd>
									 	A data structure containing the variables belonging to one particular scope (e.g. a procedure body), as well as links to other activation records.
										<br>
										Activation records are usually created (on the stack) on entry to a block and destroyed on exit. If a procedure or function may be returned as a result, stored in a variable and used in an outer scope then its activation record must be stored in a heap so that its variables still exist when it is used. Variables in the current scope are accessed via the frame pointer which points to the current activation record. Variables in an outer scope are accessed by following chains of links between activation records. There are two kinds of link - the static link and the dynamic link.	

									</dd>
								<dt id="static-scoping-rule">Static Scoping Rule</dt>
									<dd>
										Replace the reference to a variable with an ordered pair <code>(I,J</code> where <code>I = [number of pointer traversals within the stack of activation records]</code> and <code>J = [offset within the block containing the declaration for the variable]</code>. Each activation record on the stack has a pointer pointing to the next textually containing block.
									</dd>
								<dt id="display-method">Display Method</dt>
									<dd>
										Replace the reference to a variable with an ordered pair <code>(I,J)</code> where <code>I = [index in a display stack (stack of pointers)]</code> and <code>J = [offset within the block where the display pointer points]</code>. It also uses a hidden stack as well as the stack of activation records.
									</dd>
								<dt id="cret">CRET <small>Current Referencing Environment Table</small></dt>
									<dd>
										Maintain a dynamic symbol table holding symbols, whether active, and a pointer to where they are located within the stack of activation records.
										<div class="example">
											<small>(The way she wants it also represents the function stack.)</small>
											<table class="table table-bordered table-striped">
												<tr>
													<th>Symbol</th>
													<th>Active</th>
													<th>Pointer to Location</th>
												</tr>
												<tr>
													<td>i</td>
													<td>T</td>
													<td><code>&uarr; MAIN</code></td>
												</tr>
												<tr>
													<td>j</td>
													<td>T</td>
													<td><code>&uarr; A</code></td>
												</tr>
												<tr>
													<td>x</td>
													<td>F</td>
													<td><code>&uarr; NULL</code></td>
												</tr>
												<tr>
													<td>y</td>
													<td>T</td>
													<td><code>&uarr; A</code></td>
												</tr>
												<tr>
													<td>z</td>
													<td>T</td>
													<td><code>&uarr; B</code></td>
												</tr>
											</table>
										</div>
									</dd>
								<dt id="referencing-environment">Referencing Environment</dt>
									<dd>
										Set of all variables visible (having scope) for an executing statement
									</dd>
							</dl>
							<!-- END GLOSSARY SECTION -->
						</section>
						<hr>
						<section id="languages">
							<!-- LANGUAGE SPECIFIIC NOTES GO HERE -->
							<!-- END LANGUAGES SECTION -->
						</section>
						<hr>
						<section id="sample-test">
							<h1>CS 410 Midterm - Fall 2012</h1>
							<p>
								Complete in pencil. Write only on one side of your paper. Place your name at the top of each page. Fold your papers with the answers arranged in numerical order along with this test.
							</p>
							<ol>
								<li>
									Define the following:
									<ol>
										<li>Syntax</li>
										<li>Scope</li>
										<li>Semantics</li>
										<li>Orthogonality</li>
										<li>Lexeme</li>
										<li>Imperative Language</li>
										<li>Synthesized Attribute</li>
										<li>Sentence</li>
										<li>Derivation</li>
										<li>Metalanguage</li>
									</ol>
								</li>
								<li>
									Discuss features of the syntax of a programming language which can greatly influence the readability of a program.
								</li>
								<li>
									Discuss five characteristics of a "good" programming language and give examples of languages possessing each characteristic.
								</li>
								<li>
									Define ambiguous grammar and give an example of a grammar which is ambiguous and demonstrate with a sentence.
								</li>
								<li>
									Using the statement <code>A := 7 + B</code>, discuss the different binding times within the life of a programming language.
								</li>
								<li>
									Discuss the <a href="index.html#chomsky">Chomsky Hierarchy</a>.
								</li>
								<li>
									Demonstrate the <a href="#dynamic-scoping-rule">Dynamic Scoping Rule</a> for the following:
									<br>
<pre>
<code>MAIN</code> calls <code>X</code> which calls <code>Y</code> which calls <code>Z</code> and after <code>Z</code> terminates, also then calls <code>W</code>.
<code>MAIN</code> has variables a, b, and c.
<code>W</code> has variables e and f.
<code>X</code> has variables b and d.
<code>Y</code> has variables a, c, and e.
<code>Z</code> has variables c and f.
</pre>
								</li>
								<li>
									Discuss the three different methods for formally describing the semantics of a programming language.
								</li>
								<li>
									Discuss the different methods for implementing the static scoping rule and demonstrate one method on the following code. [Sample code unavailable]
								</li>
							</ol>
						</section>
					</div>
				</div>
			</div>
		</div>
	</body>
</html>